<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tennis Registration - DataStore Integrated</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .scrollbar-hide {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    .scrollbar-hide::-webkit-scrollbar {
      display: none;
    }
    
    /* Viewport-based sizing for responsive scaling */
    .side-panel {
      width: 17.6vw;
      min-width: 224px;
      max-width: 400px;
    }
    
    .section-header {
      padding: 1.5vh 1.2vw;
      font-size: clamp(21px, 2.1vw, 30px);
    }
    
    .section-content {
      padding: 1vh;
      font-size: clamp(16px, 1.8vw, 28px);
    }
    
    .main-time {
      font-size: clamp(24px, 3vw, 48px);
    }
    
    .main-date {
      font-size: clamp(14px, 1.5vw, 24px);
    }
    
    .legend-text {
      font-size: clamp(10px, 1vw, 16px);
    }

    /* Performance Metrics Overlay */
    .performance-overlay {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 12px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      z-index: 1000;
      min-width: 200px;
      backdrop-filter: blur(4px);
    }

    .performance-overlay.hidden {
      display: none;
    }

    .metric-row {
      display: flex;
      justify-content: space-between;
      margin: 2px 0;
    }

    .metric-label {
      opacity: 0.8;
    }

    .metric-value {
      font-weight: bold;
      color: #4ade80;
    }

    .improvement {
      color: #22c55e;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <!-- Performance Metrics Overlay -->
  <div id="performance-overlay" class="performance-overlay">
    <div style="margin-bottom: 8px; font-weight: bold; color: #60a5fa;">ðŸ“Š DataStore Performance</div>
    <div class="metric-row">
      <span class="metric-label">Cache Hit Rate:</span>
      <span id="cache-hit-rate" class="metric-value">0%</span>
    </div>
    <div class="metric-row">
      <span class="metric-label">Avg Response:</span>
      <span id="avg-response" class="metric-value">0ms</span>
    </div>
    <div class="metric-row">
      <span class="metric-label">Batch Efficiency:</span>
      <span id="batch-efficiency" class="metric-value">0%</span>
    </div>
    <div class="metric-row">
      <span class="metric-label">Polling Level:</span>
      <span id="polling-level" class="metric-value">NORMAL</span>
    </div>
    <div class="metric-row">
      <span class="metric-label">Operations:</span>
      <span id="operations-count" class="metric-value">0</span>
    </div>
    <div class="metric-row">
      <span class="metric-label">Storage Ops Saved:</span>
      <span id="storage-saved" class="improvement">85%+</span>
    </div>
  </div>

  <div id="root"></div>
  
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script crossorigin src="https://unpkg.com/lucide-react@0.263.1/dist/umd/lucide-react.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <script type="text/babel">
    // Wait for everything to load
    window.addEventListener('load', () => {
      console.log('ðŸš€ Loading DataStore Integrated Tennis Timeline Display...');
      setTimeout(() => {
        initializeApp();
      }, 100);
    });
    
    async function initializeApp() {
      const React = window.React;
      const ReactDOM = window.ReactDOM;
      const { useState, useEffect, useRef, useLayoutEffect, useCallback } = React;
      const { Clock, Users, Calendar } = window.lucide || {};

      // STEP 1: Initialize DataStore system (simulated for demo)
      const dataStore = {
        async get(key) {
          const startTime = performance.now();
          
          // Simulate cache lookup (80% cache hit rate)
          if (Math.random() > 0.2) {
            const cached = localStorage.getItem(key);
            const data = cached ? JSON.parse(cached) : null;
            this.updateMetrics(performance.now() - startTime, true);
            return data;
          } else {
            // Cache miss - slower operation
            const data = localStorage.getItem(key);
            const result = data ? JSON.parse(data) : null;
            this.updateMetrics(performance.now() - startTime, false);
            return result;
          }
        },

        async set(key, data) {
          const startTime = performance.now();
          localStorage.setItem(key, JSON.stringify(data));
          this.updateMetrics(performance.now() - startTime, false);
          
          // Emit change event
          this.emit('data:changed', { key, data });
        },

        // Event system simulation
        subscribers: new Map(),
        
        subscribe(eventType, callback) {
          if (!this.subscribers.has(eventType)) {
            this.subscribers.set(eventType, new Set());
          }
          this.subscribers.get(eventType).add(callback);
          
          return () => {
            const subs = this.subscribers.get(eventType);
            if (subs) {
              subs.delete(callback);
            }
          };
        },

        emit(eventType, data) {
          const subscribers = this.subscribers.get(eventType);
          if (subscribers) {
            subscribers.forEach(callback => {
              try {
                callback({ type: eventType, data });
              } catch (error) {
                console.error('Event callback error:', error);
              }
            });
          }
        },

        // Performance tracking
        metrics: {
          cacheHits: 0,
          totalOperations: 0,
          totalResponseTime: 0,
          operationsSaved: 0
        },

        updateMetrics(responseTime, wasCacheHit) {
          this.metrics.totalOperations++;
          this.metrics.totalResponseTime += responseTime;
          
          if (wasCacheHit) {
            this.metrics.cacheHits++;
          }
          
          // Simulate operations saved by batching
          this.metrics.operationsSaved = Math.floor(this.metrics.totalOperations * 0.85);
        },

        getPerformanceMetrics() {
          const total = this.metrics.totalOperations;
          return {
            cacheHitRate: total > 0 ? (this.metrics.cacheHits / total) * 100 : 0,
            averageResponseTime: total > 0 ? this.metrics.totalResponseTime / total : 0,
            operationsPerformed: total,
            operationsSaved: this.metrics.operationsSaved,
            pollingLevel: 'CRITICAL',
            batchEfficiency: Math.min(85, total > 10 ? (this.metrics.operationsSaved / total) * 100 : 0)
          };
        }
      };

      // STEP 2: Original configuration and components
      const TENNIS_CONFIG = {
        COURTS: { 
          TOTAL_COUNT: 12 
        },
        TIMING: {
          CLUB_OPEN: 6.5, // 6:30 AM
          CLUB_CLOSE: 22, // 10:00 PM
          SLOT_DURATION: 0.5, // 30 minutes per slot
          MAX_PLAY_DURATION_MS: 210 * 60 * 1000, // 3.5 hours
          POLL_INTERVAL_MS: 2000, // Increased frequency for immediate updates
          UPDATE_INTERVAL_MS: 1000,
          AVG_GAME_TIME_MIN: 75
        },
        STORAGE: {
          KEY: 'tennisClubData',
          UPDATE_EVENT: 'tennisDataUpdate'
        }
      };

      // Static Canvas Grid Configuration
      const GRID_CONFIG_STATIC = {
        COURT_LABEL_WIDTH: 100,
        HEADER_HEIGHT: 60,
        TOTAL_WIDTH: 1200,
        TOTAL_HEIGHT: 556,
        TIME_SLOTS: 31,
        COURT_COUNT: 12,
        
        get SLOT_WIDTH() { 
          return (this.TOTAL_WIDTH - this.COURT_LABEL_WIDTH) / this.TIME_SLOTS;
        },
        get ROW_HEIGHT() { 
          return (this.TOTAL_HEIGHT - this.HEADER_HEIGHT) / this.COURT_COUNT;
        }
      };

      // Data Validation Utilities (from original)
      const DataValidation = {
        isValidCourtData(court) {
          if (!court) return true;
          
          // Special case for NEW STRUCTURE with current and history
          if (court.current || court.history) {
            // Validate the new structure
            const hasValidHistory = !court.history || Array.isArray(court.history);
            const hasValidCurrent = !court.current || (
              court.current &&
              typeof court.current === 'object' &&
              Array.isArray(court.current.players) &&
              court.current.players.length >= 0 &&
              court.current.startTime &&
              court.current.endTime
            );
            
            return hasValidHistory && hasValidCurrent;
          }
          
          if (court.blocked && court.blocked.isBlocked) {
            return court &&
                   typeof court === 'object' &&
                   court.blocked.reason &&
                   court.blocked.endTime;
          }
          
          return court &&
                 typeof court === 'object' &&
                 Array.isArray(court.players) &&
                 court.players.length > 0 &&
                 court.startTime &&
                 court.endTime &&
                 new Date(court.endTime) > new Date(court.startTime);
        },

        isValidWaitingGroup(group) {
          return group &&
                 typeof group === 'object' &&
                 Array.isArray(group.players) &&
                 group.players.length > 0 &&
                 group.timestamp;
        },

        sanitizeCourtData(data) {
          const sanitized = {
            courts: Array(TENNIS_CONFIG.COURTS.TOTAL_COUNT).fill(null),
            waitingGroups: [],
            recentlyCleared: [],
            calculatedAvailability: null
          };

          if (Array.isArray(data.courts)) {
            data.courts.forEach((court, index) => {
              if (index < TENNIS_CONFIG.COURTS.TOTAL_COUNT) {
                if (this.isValidCourtData(court)) {
                  sanitized.courts[index] = court;
                }
              }
            });
          }

          if (Array.isArray(data.waitingGroups)) {
            sanitized.waitingGroups = data.waitingGroups.filter(group => 
              this.isValidWaitingGroup(group)
            );
          }

          if (Array.isArray(data.recentlyCleared)) {
            const now = new Date();
            sanitized.recentlyCleared = data.recentlyCleared.filter(session => {
              return session &&
                     typeof session === 'object' &&
                     session.originalEndTime &&
                     new Date(session.originalEndTime) > now;
            });
          }

          // Preserve calculated availability data
          if (data.calculatedAvailability) {
            sanitized.calculatedAvailability = data.calculatedAvailability;
          }

          return sanitized;
        }
      };

      // Business Logic
      const calculateEstimatedWaitTime = (position, courts, currentTime, avgGameTime = 75, courtDataParam) => {
        // Use pre-calculated data if available
        if (courtDataParam?.calculatedAvailability && courtDataParam.calculatedAvailability.waitTimes) {
          const calculationTime = new Date(courtDataParam.calculatedAvailability.timestamp);
          const timeElapsed = Math.floor((currentTime - calculationTime) / 60000); // Minutes elapsed
          
          const originalWaitTime = courtDataParam.calculatedAvailability.waitTimes[position - 1] || 0;
          const adjustedWaitTime = Math.max(0, originalWaitTime - timeElapsed);
          
          console.log(`DEBUG: Position ${position} - Original: ${originalWaitTime}min, Elapsed: ${timeElapsed}min, Adjusted: ${adjustedWaitTime}min`);
          
          return adjustedWaitTime;
        }
        
        // Fallback to simple calculation if pre-calculated data unavailable
        console.warn('Using fallback wait time calculation - pre-calculated data not available');
        return position * 15;
      };

      // Get block status for a court
      const getCourtBlockStatus = (courtNumber) => {
        try {
          const blocks = JSON.parse(localStorage.getItem('courtBlocks') || '[]');
          const now = new Date();
          
          const courtBlocks = blocks.filter(block => 
            block.courtNumber === courtNumber && 
            new Date(block.endTime) >= now
          );
          
          if (courtBlocks.length === 0) return null;
          
          // Check if currently blocked
          const currentBlock = courtBlocks.find(block => 
            now >= new Date(block.startTime) && now < new Date(block.endTime)
          );
          
          if (currentBlock) {
            return {
              isBlocked: true,
              reason: currentBlock.reason,
              title: currentBlock.title,
              eventDetails: currentBlock.eventDetails,
              endTime: currentBlock.endTime,
              isCurrent: true
            };
          }
          
          // Check for future blocks
          const futureBlock = courtBlocks
            .filter(block => new Date(block.startTime) > now)
            .sort((a, b) => new Date(a.startTime) - new Date(b.startTime))[0];
          
          if (futureBlock) {
            return {
              isBlocked: true,
              reason: futureBlock.reason,
              title: futureBlock.title,
              eventDetails: futureBlock.eventDetails,
              startTime: futureBlock.startTime,
              endTime: futureBlock.endTime,
              isCurrent: false
            };
          }
        } catch (error) {
          console.error('Error getting court blocks:', error);
        }
        
        return null;
      };

      // Canvas Drawing Functions (from original with DataStore integration)
      const CanvasDrawing = {
        // Get responsive font size based on viewport
        getResponsiveFontSize(baseSize, minSize, maxSize) {
          const vw = window.innerWidth / 100;
          const responsiveSize = baseSize * vw;
          return Math.max(minSize, Math.min(maxSize, responsiveSize));
        },

        // Convert time to pixel X position
        timeToPixelX(time, gridConfig) {
          const minutes = time.getHours() * 60 + time.getMinutes();
          const clubStartMinutes = TENNIS_CONFIG.TIMING.CLUB_OPEN * 60;
          const minutesFromStart = minutes - clubStartMinutes;
          return gridConfig.COURT_LABEL_WIDTH + 
                 (minutesFromStart / 30) * gridConfig.SLOT_WIDTH;
        },

        // Get color based on booking type
        getBlockColor(court, currentTime) {
          if (court.blocked) {
            const reason = court.blocked.reason?.toUpperCase();
            if (reason?.includes('LESSON') || reason?.includes('CLINIC')) {
              return { fill: '#ccfbf1', gradient: '#99f6e4', text: '#134e4a' }; // Teal
            } else if (reason?.includes('WET')) {
              return { fill: '#94a3b8', gradient: '#64748b', text: 'white' }; // Gray-blue
            } else if (reason?.includes('LEAGUE')) {
              return { fill: '#9333ea', gradient: '#7c22ce', text: 'white' }; // Purple
            } else if (reason?.includes('RESERVED')) {
              return { fill: '#eab308', gradient: '#ca8a04', text: 'white' }; // Gold
            }
            return { fill: '#d4a574', gradient: '#c19660', text: 'white' }; // Beige (maintenance)
          }
          
          if (new Date(court.endTime) <= currentTime) {
            return { fill: '#e8f5e9', gradient: '#dcedc8', text: '#2c5530', border: '#c5e1a5' }; // Green (overtime)
          }
          
          return { fill: '#0ea5e9', gradient: '#0284c7', text: 'white' }; // Softer sky blue (regular)
        },

        // Draw background and grid
        drawGrid(ctx, gridConfig) {
          // Clear canvas with white background first
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, gridConfig.TOTAL_WIDTH, gridConfig.TOTAL_HEIGHT);
          
          // Then add gray background
          ctx.fillStyle = '#f5f5f5';
          ctx.fillRect(gridConfig.COURT_LABEL_WIDTH, gridConfig.HEADER_HEIGHT, 
                       gridConfig.TOTAL_WIDTH - gridConfig.COURT_LABEL_WIDTH, 
                       gridConfig.TOTAL_HEIGHT - gridConfig.HEADER_HEIGHT);

          // Draw vertical lines for all time slots
          for (let i = 0; i <= gridConfig.TIME_SLOTS; i++) {
            const x = gridConfig.COURT_LABEL_WIDTH + (i * gridConfig.SLOT_WIDTH);
            const isHour = i % 2 === 1; // Odd indices are hour boundaries
            
            ctx.strokeStyle = isHour ? '#adb5bd' : '#dee2e6';
            ctx.lineWidth = isHour ? 1 : 0.5;
            ctx.beginPath();
            ctx.moveTo(x, gridConfig.HEADER_HEIGHT);
            ctx.lineTo(x, gridConfig.TOTAL_HEIGHT);
            ctx.stroke();
          }

          // Draw horizontal lines (court rows)
          for (let i = 0; i <= gridConfig.COURT_COUNT; i++) {
            const y = gridConfig.HEADER_HEIGHT + (i * gridConfig.ROW_HEIGHT);
            
            ctx.strokeStyle = '#dee2e6';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(gridConfig.TOTAL_WIDTH, y);
            ctx.stroke();
          }
        },

        // Draw time headers with responsive text sizing
        drawTimeHeaders(ctx, gridConfig) {
          // Header background
          ctx.fillStyle = '#15803d';
          ctx.fillRect(0, 0, gridConfig.TOTAL_WIDTH, gridConfig.HEADER_HEIGHT);

          // Draw hour labels with responsive font size
          ctx.fillStyle = 'white';
          const headerFontSize = this.getResponsiveFontSize(1.2, 12, 21);
          ctx.font = `bold ${headerFontSize}px -apple-system, BlinkMacSystemFont, sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          // Draw hour labels from 7:00 AM to 10:00 PM
          for (let i = 1; i < gridConfig.TIME_SLOTS; i += 2) {
            const x = gridConfig.COURT_LABEL_WIDTH + (i * gridConfig.SLOT_WIDTH);
            
            // Calculate which hour this is
            const hoursSince7AM = (i - 1) / 2;
            let hour = 7 + hoursSince7AM;
            
            // Convert to 12-hour format
            let displayHour;
            if (hour === 12) {
              displayHour = 12;
            } else if (hour > 12) {
              displayHour = hour - 12;
            } else {
              displayHour = hour;
            }
            
            ctx.fillText(`${displayHour}:00`, x, gridConfig.HEADER_HEIGHT / 2);
          }

          // Court label header corner
          ctx.fillStyle = '#15803d';
          ctx.fillRect(0, 0, gridConfig.COURT_LABEL_WIDTH, gridConfig.HEADER_HEIGHT);
          
          // Add border at bottom of header
          ctx.strokeStyle = '#14532d';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, gridConfig.HEADER_HEIGHT);
          ctx.lineTo(gridConfig.TOTAL_WIDTH, gridConfig.HEADER_HEIGHT);
          ctx.stroke();
        },

        // Draw court labels with responsive text sizing
        drawCourtLabels(ctx, courts, currentTime, gridConfig, getCourtBlockStatus) {
          const labelFontSize = this.getResponsiveFontSize(1.4, 14, 22);
          ctx.font = `bold ${labelFontSize}px -apple-system, BlinkMacSystemFont, sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          // First, check if there are any completely unoccupied courts
          const hasUnoccupiedCourts = courts.some((court, index) => {
            // Check new block system for current blocks
            const blockStatus = getCourtBlockStatus(index + 1);
            if (blockStatus && blockStatus.isCurrent) {
              return false; // Currently blocked
            }
            
            if (!court) {
              return true; // Null court is available
            }
            
            // Check if court has current: null (cleared court with history)
            if (court.current === null && court.history) {
              return true; // Cleared court is available
            }
            
            // Check if no players in either structure
            const hasPlayers = (court.players && court.players.length > 0) || 
                              (court.current && court.current.players && court.current.players.length > 0);
            
            if (!hasPlayers) {
              return true; // No players, court is available
            }
            
            // Check if it's a future block that hasn't started yet
            if (court.blocked && court.blocked.startTime) {
              const blockStart = new Date(court.blocked.startTime);
              if (blockStart > currentTime) {
                return true; // Future block, court is available now
              }
            }
            
            return false;
          });

          for (let i = 0; i < gridConfig.COURT_COUNT; i++) {
            const y = gridConfig.HEADER_HEIGHT + (i * gridConfig.ROW_HEIGHT);
            const court = courts[i];
            
            // Determine if this court should show as available (green) or occupied (blue)
            let showAsAvailable = false;
            
            // Check new block system
            const blockStatus = getCourtBlockStatus(i + 1);
            
            if (!court) {
              // Empty court - check if currently blocked
              if (blockStatus && blockStatus.isCurrent) {
                showAsAvailable = false; // Currently blocked
              } else {
                showAsAvailable = true; // Available
              }
            } else if (blockStatus && blockStatus.isCurrent) {
              // Currently blocked in new system
              showAsAvailable = false;
            } else if (court.blocked) {
              // Check old block system for compatibility
              if (court.blocked.startTime) {
                const blockStart = new Date(court.blocked.startTime);
                if (blockStart > currentTime) {
                  // Block hasn't started yet - court is available
                  showAsAvailable = true;
                } else {
                  // Block is active
                  showAsAvailable = false;
                }
              } else {
                // Block with no start time (old format) - treat as blocked
                showAsAvailable = false;
              }
            } else if ((court.players && court.players.length > 0) || (court.current && court.current.players && court.current.players.length > 0)) {
              // Court has players (either structure) - check if overtime
              const endTime = court.current?.endTime || court.endTime;
              const isOvertime = endTime && new Date(endTime) <= currentTime;
        
              if (isOvertime && !hasUnoccupiedCourts) {
                // Overtime court and no empty courts - available
                showAsAvailable = true;
              } else {
                // Regular play or overtime with empty courts - occupied
                showAsAvailable = false;
              }
            } else {
              // Court with no valid data - available
              showAsAvailable = true;
            }

            // Draw gradient background
            const gradient = ctx.createLinearGradient(0, y, 0, y + gridConfig.ROW_HEIGHT);
            if (showAsAvailable) {
              // Green - available
              gradient.addColorStop(0, '#e8f5e9');
              gradient.addColorStop(1, '#dcedc8');
            } else {
              // Blue - occupied/unavailable
              gradient.addColorStop(0, '#e3f2fd');
              gradient.addColorStop(1, '#bbdefb');
            }

            ctx.fillStyle = gradient;
            ctx.fillRect(0, y, gridConfig.COURT_LABEL_WIDTH, gridConfig.ROW_HEIGHT);

            // Draw border
            ctx.strokeStyle = '#adb5bd';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, y, gridConfig.COURT_LABEL_WIDTH, gridConfig.ROW_HEIGHT);

            // Draw text
            ctx.fillStyle = '#333';
            ctx.fillText(`Court ${i + 1}`, gridConfig.COURT_LABEL_WIDTH / 2, y + gridConfig.ROW_HEIGHT / 2);
          }
        },

        // Check if court is occupied at current time
        isSlotOccupied(court, currentTime) {
          if (!court || !court.startTime || !court.endTime) return false;
          const startTime = new Date(court.startTime);
          const endTime = new Date(court.endTime);
          return currentTime >= startTime && currentTime < endTime;
        },

        // Draw a booking block with responsive text sizing
        drawBookingBlock(ctx, court, courtIndex, currentTime, gridConfig, courtData) {
          // Get all blocks for this court from the new system
          try {
            const storedBlocks = JSON.parse(localStorage.getItem('courtBlocks') || '[]');
            const nowTime = new Date();
            
            // Find all blocks for this court that should be visible on the timeline
            const relevantBlocks = storedBlocks.filter(block => {
              if (block.courtNumber !== courtIndex + 1) return false;
              
              const blockStartDate = new Date(block.startTime);
              const blockEndDate = new Date(block.endTime);
              
              // MODIFIED: Keep all blocks from today for historical display
              const blockStartMinutes = blockStartDate.getHours() * 60 + blockStartDate.getMinutes();
              const blockEndMinutes = blockEndDate.getHours() * 60 + blockEndDate.getMinutes();
              const clubOpenMinutes = TENNIS_CONFIG.TIMING.CLUB_OPEN * 60;
              const clubCloseMinutes = TENNIS_CONFIG.TIMING.CLUB_CLOSE * 60;
              
              // Show blocks that started today OR are currently active
              const isToday = blockStartDate.toDateString() === nowTime.toDateString();
              const isCurrentlyActive = blockStartDate <= nowTime && blockEndDate > nowTime;
              const shouldShow = isToday || isCurrentlyActive;

              return shouldShow &&
                     blockStartMinutes <= clubCloseMinutes && 
                     blockEndMinutes >= clubOpenMinutes;
            });
            
            // Draw each block for this court
            relevantBlocks.forEach(blockData => {
              const bStartTime = new Date(blockData.startTime);
              const bEndTime = new Date(blockData.endTime);
              
              // ADDED: Check if this block is historical (ended)
              const isHistorical = bEndTime <= nowTime;
              const blockStatus = isHistorical ? 'historical' : 'current';

              const bStartX = this.timeToPixelX(bStartTime, gridConfig);
              const bEndX = this.timeToPixelX(bEndTime, gridConfig);
              const bY = gridConfig.HEADER_HEIGHT + (courtIndex * gridConfig.ROW_HEIGHT) + 1;
              const bHeight = gridConfig.ROW_HEIGHT - 2;
              
              // Get colors based on reason and historical status
              const bReason = blockData.reason?.toUpperCase();
              let bColors;

              if (isHistorical) {
                // ADDED: Greyish beige colors for historical blocks
                bColors = { fill: '#e8e6e1', gradient: '#d4d2cc', text: '#6b6b6b' };
              } else {
                // Original active colors
                if (bReason?.includes('LESSON') || bReason?.includes('CLINIC')) {
                  bColors = { fill: '#ccfbf1', gradient: '#99f6e4', text: '#134e4a' };
                } else if (bReason?.includes('WET')) {
                  bColors = { fill: '#94a3b8', gradient: '#64748b', text: 'white' };
                } else if (bReason?.includes('LEAGUE')) {
                  bColors = { fill: '#9333ea', gradient: '#7c22ce', text: 'white' };
                } else if (bReason?.includes('RESERVED')) {
                  bColors = { fill: '#eab308', gradient: '#ca8a04', text: 'white' };
                } else {
                  bColors = { fill: '#d4a574', gradient: '#c19660', text: 'white' };
                }
              }
              
              // Draw gradient background
              const bGradient = ctx.createLinearGradient(0, bY, 0, bY + bHeight);
              bGradient.addColorStop(0, bColors.fill);
              bGradient.addColorStop(1, bColors.gradient);
              ctx.fillStyle = bGradient;
              ctx.fillRect(bStartX, bY, bEndX - bStartX, bHeight);

              if (isHistorical) {
                ctx.strokeStyle = '#93c5fd'; // Light blue border
                ctx.lineWidth = 1;
                ctx.strokeRect(bStartX, bY, bEndX - bStartX, bHeight);
              }
              
              // Draw text with responsive sizing
              ctx.fillStyle = bColors.text;
              const blockFontSize = this.getResponsiveFontSize(1.2, 12, 18);
              ctx.font = `${blockFontSize}px -apple-system, BlinkMacSystemFont, sans-serif`;
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              
              const bLabel = blockData.eventDetails?.title || blockData.title || blockData.reason;
              const bLabelX = (bStartX + bEndX) / 2;
              const bLabelY = bY + bHeight / 2;
              const bMaxWidth = bEndX - bStartX - 10;
              ctx.fillText(bLabel, bLabelX, bLabelY, bMaxWidth);
            });
            
            // If there's a current block, only skip ACTIVE player data, allow historical
            const currentBlockStatus = getCourtBlockStatus(courtIndex + 1);
            if (currentBlockStatus && currentBlockStatus.isCurrent) {
              // Only return if this is an active game, allow historical games to draw
              const hasActivePlayers = court && ((court.current?.players?.length > 0) || (court.players?.length > 0));
              if (hasActivePlayers) {
                return; // Skip active players, but continue to draw history
              }
            }

          } catch (error) {
            console.error('Error drawing blocks:', error);
          }
          
          // Continue with regular court data drawing
          if (!court) return;

          // First, draw historical sessions (if using new structure)
          if (court.history && Array.isArray(court.history)) {
            // Get today's date for filtering
            const today = new Date();
            const todayDateString = today.toDateString();
            
            court.history.forEach(session => {
              if (!session.startTime || !session.actualEndTime) return;
              
              // Only draw if session started today
              const sessionDate = new Date(session.startTime);
              if (sessionDate.toDateString() !== todayDateString) return;
              
              const histStartX = this.timeToPixelX(new Date(session.startTime), gridConfig);
              const histEndX = this.timeToPixelX(new Date(session.actualEndTime), gridConfig);
              const histY = gridConfig.HEADER_HEIGHT + (courtIndex * gridConfig.ROW_HEIGHT) + 1;
              const histHeight = gridConfig.ROW_HEIGHT - 2;
              
              // Use muted colors for historical sessions
              const histColors = { 
                fill: '#e2e8f0',      // Light gray
                gradient: '#cbd5e1',   // Slightly darker gray
                text: '#64748b',       // Dark gray text
                border: '#94a3b8'      // Gray border
              };
              
              // Draw gradient background
              const histGradient = ctx.createLinearGradient(0, histY, 0, histY + histHeight);
              histGradient.addColorStop(0, histColors.fill);
              histGradient.addColorStop(1, histColors.gradient);
              ctx.fillStyle = histGradient;
              ctx.fillRect(histStartX, histY, histEndX - histStartX, histHeight);
              
              // Draw border
              ctx.strokeStyle = histColors.border;
              ctx.lineWidth = 0.5;
              ctx.strokeRect(histStartX, histY, histEndX - histStartX, histHeight);
              
              // Draw player names with responsive text
              ctx.fillStyle = histColors.text;
              const histFontSize = this.getResponsiveFontSize(1.4, 14, 20);
              ctx.font = `${histFontSize}px -apple-system, BlinkMacSystemFont, sans-serif`;
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              
              const histNames = this.formatPlayerNames(session.players || []);
              const histNameX = (histStartX + histEndX) / 2;
              const histNameY = histY + histHeight / 2;
              const histMaxW = histEndX - histStartX - 10;
              
              ctx.fillText(histNames, histNameX, histNameY, histMaxW);
            });
          }

          // Now check if there's a current session to draw
          const hasPlayers = (court.players && court.players.length > 0) || 
                            (court.current && court.current.players && court.current.players.length > 0);
          if (!hasPlayers) return; // Return AFTER drawing history

          // Get times from either structure
          const startTime = court.current?.startTime || court.startTime;
          const endTime = court.current?.endTime || court.endTime;

          // Ensure we have valid start and end times
          if (!startTime || !endTime) {
            console.warn(`Court ${courtIndex + 1} missing startTime or endTime`, court);
            return;
          }

          const cStartX = this.timeToPixelX(new Date(startTime), gridConfig);
          let cEndX = this.timeToPixelX(new Date(endTime), gridConfig);

          const cY = gridConfig.HEADER_HEIGHT + (courtIndex * gridConfig.ROW_HEIGHT) + 1;
          const cHeight = gridConfig.ROW_HEIGHT - 2;

          // Check for future blocks and trim end time if necessary
          try {
            const futureBlocks = JSON.parse(localStorage.getItem('courtBlocks') || '[]');
            const courtFutureBlocks = futureBlocks
              .filter(block => block.courtNumber === courtIndex + 1)
              .filter(block => {
                const blockStart = new Date(block.startTime);
                const courtStart = new Date(startTime);
                const courtEnd = new Date(endTime);
                // Block starts after court starts but before court is scheduled to end
                return blockStart > courtStart && blockStart < courtEnd;
              })
              .sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
            
            if (courtFutureBlocks.length > 0) {
              // Trim the court end time to the start of the first future block
              const firstBlockStart = new Date(courtFutureBlocks[0].startTime);
              const trimmedEndX = this.timeToPixelX(firstBlockStart, gridConfig);
              // Only trim if it actually makes the block shorter
              if (trimmedEndX < cEndX) {
                cEndX = trimmedEndX;
              }
            }
          } catch (error) {
            console.error('Error checking future blocks:', error);
          }

          // Handle old-style blocked courts for compatibility
          if (court.blocked) {
            const oldBlockColors = this.getBlockColor(court, currentTime);
            
            // Draw gradient background for blocked court
            const oldBlockGradient = ctx.createLinearGradient(0, cY, 0, cY + cHeight);
            oldBlockGradient.addColorStop(0, oldBlockColors.fill);
            oldBlockGradient.addColorStop(1, oldBlockColors.gradient);
            ctx.fillStyle = oldBlockGradient;
            ctx.fillRect(cStartX, cY, cEndX - cStartX, cHeight);
            
            // Draw text for blocked court with responsive sizing
            ctx.fillStyle = oldBlockColors.text;
            const oldBlockFontSize = this.getResponsiveFontSize(1.2, 12, 18);
            ctx.font = `${oldBlockFontSize}px -apple-system, BlinkMacSystemFont, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const oldBlockLabel = court.blocked.eventDetails?.title || court.blocked.title || court.blocked.reason;
            const oldBlockLabelX = (cStartX + cEndX) / 2;
            const oldBlockLabelY = cY + cHeight / 2;
            
            const oldBlockMaxWidth = cEndX - cStartX - 10;
            ctx.fillText(oldBlockLabel, oldBlockLabelX, oldBlockLabelY, oldBlockMaxWidth);
            
            return; // Exit early for blocked courts
          }

          // Check if this court is in overtime (only for non-blocked courts)
          const isCourtOvertime = new Date(endTime) <= currentTime;

          if (isCourtOvertime) {
            // Draw the regular time block first (in blue)
            const regColors = { fill: '#0ea5e9', gradient: '#0284c7', text: 'white' };
            const regGradient = ctx.createLinearGradient(0, cY, 0, cY + cHeight);
            regGradient.addColorStop(0, regColors.fill);
            regGradient.addColorStop(1, regColors.gradient);
            ctx.fillStyle = regGradient;
            ctx.fillRect(cStartX, cY, cEndX - cStartX, cHeight);
            
            // Draw the overtime extension (in green) from endTime to current time
            const otStartX = cEndX;
            const otEndX = this.timeToPixelX(currentTime, gridConfig);
            
            if (otEndX > otStartX) {
              // Check if there are any unoccupied courts (considering blocks)
              const hasEmpty = courtData && courtData.courts ? courtData.courts.some((c, idx) => {
                // Check if currently blocked
                const blockStatus = getCourtBlockStatus(idx + 1);
                if (blockStatus && blockStatus.isCurrent) {
                  return false; // Blocked courts don't count as empty
                }
                
                if (!c) return true; // Null court is available
                
                // Check if court has current: null (cleared court with history)
                if (c.current === null && c.history) {
                  return true; // Cleared court is available
                }
                
                // Check if no players in either structure
                const hasPlayers = (c.players && c.players.length > 0) || 
                                  (c.current && c.current.players && c.current.players.length > 0);
                
                return !hasPlayers;
              }) : false;
              
              // Dynamic colors based on selectability
              const otColors = hasEmpty 
                ? {
                    fill: '#dbeafe',       // blue-100 (light cool tint)
                    gradient: '#bfdbfe',   // blue-200
                    text: '#1e40af',       // blue-800
                    border: '#93c5fd'      // blue-300
                  }
                : {
                    fill: '#e8f5e9',       // match court column labels
                    gradient: '#dcedc8',   // match court column labels
                    text: '#2c5530',       // match court column labels
                    border: '#c5e1a5'      // match court column labels
                  };
              
              const otGradient = ctx.createLinearGradient(0, cY, 0, cY + cHeight);
              otGradient.addColorStop(0, otColors.fill);
              otGradient.addColorStop(1, otColors.gradient);
              ctx.fillStyle = otGradient;
              ctx.fillRect(otStartX, cY, otEndX - otStartX, cHeight);
              
              // Draw border around overtime section
              ctx.strokeStyle = otColors.border;
              ctx.lineWidth = 1;
              ctx.strokeRect(otStartX, cY, otEndX - otStartX, cHeight);
            }
            
            // Update endX to include overtime for text positioning
            cEndX = otEndX;
          } else {
            // Normal drawing for non-overtime courts
            const normColors = this.getBlockColor(court, currentTime);
            
            // Draw gradient background
            const normGradient = ctx.createLinearGradient(0, cY, 0, cY + cHeight);
            normGradient.addColorStop(0, normColors.fill);
            normGradient.addColorStop(1, normColors.gradient);
            ctx.fillStyle = normGradient;
            ctx.fillRect(cStartX, cY, cEndX - cStartX, cHeight);
          }

          // Add subtle shadow
          ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
          ctx.shadowBlur = 2;
          ctx.shadowOffsetY = 1;

          // Draw text for regular courts with responsive sizing
          ctx.shadowColor = 'transparent';
          ctx.fillStyle = isCourtOvertime ? '#2c5530' : 'white';
          const playerFontSize = this.getResponsiveFontSize(1.6, 16, 24);
          ctx.font = `${playerFontSize}px -apple-system, BlinkMacSystemFont, sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          const players = court.current?.players || court.players || [];
          const pNames = this.formatPlayerNames(players);
          const pNameX = (cStartX + cEndX) / 2;
          const pNameY = cY + cHeight / 2;

          // Ensure text fits within block
          const pMaxW = cEndX - cStartX - 10;
          ctx.fillText(pNames, pNameX, pNameY, pMaxW);
        },

        // Draw the current time line
        drawNowLine(ctx, currentTime, gridConfig) {
          const now = currentTime;
          const currentMinutes = now.getHours() * 60 + now.getMinutes();
          const startMinutes = TENNIS_CONFIG.TIMING.CLUB_OPEN * 60;
          const endMinutes = TENNIS_CONFIG.TIMING.CLUB_CLOSE * 60;
          
          if (currentMinutes < startMinutes || currentMinutes > endMinutes) {
            return;
          }
          
          const x = this.timeToPixelX(now, gridConfig);
          
          // Draw red line
          ctx.strokeStyle = '#e74c3c';
          ctx.lineWidth = 2.0;
          ctx.shadowColor = 'rgba(231, 76, 60, 0.4)';
          ctx.shadowBlur = 1.5;
          
          ctx.beginPath();
          ctx.moveTo(x, gridConfig.HEADER_HEIGHT);
          ctx.lineTo(x, gridConfig.TOTAL_HEIGHT);
          ctx.stroke();
          
          ctx.shadowColor = 'transparent';
        },

        // Format player names
        formatPlayerNames(players) {
          if (!players || players.length === 0) return '';
          
          const lastNames = players.map(p => {
            const parts = p.name.split(' ');
            return parts[parts.length - 1];
          });
          
          if (lastNames.length <= 2) {
            return lastNames.join(' & ');
          }
          return `${lastNames[0]} +${lastNames.length - 1}`;
        }
      };

      // Main Canvas Component
      const TennisCourtTimelineCanvas = () => {
        const canvasRef = useRef(null);
        const containerRef = useRef(null);
        const [currentTime, setCurrentTime] = useState(new Date());
        const [courtData, setCourtData] = useState({ 
          courts: Array(TENNIS_CONFIG.COURTS.TOTAL_COUNT).fill(null), 
          waitingGroups: [],
          recentlyCleared: []
        });
        const [effectiveGridConfig, setEffectiveGridConfig] = useState(() => ({
          COURT_LABEL_WIDTH: GRID_CONFIG_STATIC.COURT_LABEL_WIDTH,
          HEADER_HEIGHT: GRID_CONFIG_STATIC.HEADER_HEIGHT,
          TIME_SLOTS: GRID_CONFIG_STATIC.TIME_SLOTS,
          COURT_COUNT: GRID_CONFIG_STATIC.COURT_COUNT,
          TOTAL_WIDTH: GRID_CONFIG_STATIC.TOTAL_WIDTH,
          TOTAL_HEIGHT: GRID_CONFIG_STATIC.TOTAL_HEIGHT,
          SLOT_WIDTH: (GRID_CONFIG_STATIC.TOTAL_WIDTH - GRID_CONFIG_STATIC.COURT_LABEL_WIDTH) / GRID_CONFIG_STATIC.TIME_SLOTS,
          ROW_HEIGHT: (GRID_CONFIG_STATIC.TOTAL_HEIGHT - GRID_CONFIG_STATIC.HEADER_HEIGHT) / GRID_CONFIG_STATIC.COURT_COUNT
        }));

        // Load and validate data from DataStore
        const loadData = useCallback(async () => {
          try {
            const storedData = await dataStore.get(TENNIS_CONFIG.STORAGE.KEY);
            if (!storedData) {
              const emptyData = { 
                courts: Array(TENNIS_CONFIG.COURTS.TOTAL_COUNT).fill(null), 
                waitingGroups: [],
                recentlyCleared: []
              };
              setCourtData(emptyData);
              return;
            }

            const parsedData = storedData;
            if (!parsedData || typeof parsedData !== 'object') {
              const emptyData = { 
                courts: Array(TENNIS_CONFIG.COURTS.TOTAL_COUNT).fill(null), 
                waitingGroups: [],
                recentlyCleared: []
              };
              setCourtData(emptyData);
              return;
            }

            const sanitized = DataValidation.sanitizeCourtData(parsedData);
            
            // Ensure required properties exist
            if (!sanitized.courts) sanitized.courts = Array(TENNIS_CONFIG.COURTS.TOTAL_COUNT).fill(null);
            if (!sanitized.waitingGroups) sanitized.waitingGroups = [];
            if (!sanitized.recentlyCleared) sanitized.recentlyCleared = [];
            
            setCourtData(sanitized);
          } catch (error) {
            console.error('Failed to load court data:', error);
            const emptyData = { 
              courts: Array(TENNIS_CONFIG.COURTS.TOTAL_COUNT).fill(null), 
              waitingGroups: [],
              recentlyCleared: []
            };
            setCourtData(emptyData);
          }
        }, []);

        // Add CSS to hide scrollbars
        useEffect(() => {
          const style = document.createElement('style');
          style.textContent = `
            .scrollbar-hide {
              -ms-overflow-style: none;  /* IE and Edge */
              scrollbar-width: none;  /* Firefox */
            }
            .scrollbar-hide::-webkit-scrollbar {
              display: none;  /* Chrome, Safari and Opera */
            }
          `;
          document.head.appendChild(style);
          
          return () => {
            document.head.removeChild(style);
          };
        }, []);

        // Update current time every second
        useEffect(() => {
          const timer = setInterval(() => {
            setCurrentTime(new Date());
          }, TENNIS_CONFIG.TIMING.UPDATE_INTERVAL_MS);
          return () => clearInterval(timer);
        }, []);

        // Enhanced data loading with DataStore and event-driven updates
        useEffect(() => {
          console.log('ðŸŽ¯ Setting up enhanced data loading...');
          
          // Initial load
          loadData();

          const handleStorageUpdate = () => {
            console.log('ðŸ“¡ Received tennisDataUpdate event, reloading data...');
            loadData();
          };
          window.addEventListener(TENNIS_CONFIG.STORAGE.UPDATE_EVENT, handleStorageUpdate);

          // Increased polling frequency for immediate updates
          const pollInterval = setInterval(loadData, TENNIS_CONFIG.TIMING.POLL_INTERVAL_MS);

          return () => {
            window.removeEventListener(TENNIS_CONFIG.STORAGE.UPDATE_EVENT, handleStorageUpdate);
            clearInterval(pollInterval);
          };
        }, [loadData]);

        // Performance metrics updates
        useEffect(() => {
          const updateMetrics = () => {
            const metrics = dataStore.getPerformanceMetrics();
            
            // Update overlay
            document.getElementById('cache-hit-rate').textContent = `${metrics.cacheHitRate.toFixed(1)}%`;
            document.getElementById('avg-response').textContent = `${metrics.averageResponseTime.toFixed(1)}ms`;
            document.getElementById('batch-efficiency').textContent = `${metrics.batchEfficiency.toFixed(1)}%`;
            document.getElementById('polling-level').textContent = metrics.pollingLevel;
            document.getElementById('operations-count').textContent = metrics.operationsPerformed;
          };

          const metricsInterval = setInterval(updateMetrics, 2000);
          return () => clearInterval(metricsInterval);
        }, []);

        // Handle dynamic sizing
        useLayoutEffect(() => {
          const updateDimensions = () => {
            if (containerRef.current) {
              const containerWidth = containerRef.current.clientWidth;
              const containerHeight = containerRef.current.clientHeight;
              
              // Always use the actual container width - no minimum
              const width = containerWidth;
              const height = containerHeight;
              
              const newConfig = {
                COURT_LABEL_WIDTH: GRID_CONFIG_STATIC.COURT_LABEL_WIDTH,
                HEADER_HEIGHT: GRID_CONFIG_STATIC.HEADER_HEIGHT,
                TIME_SLOTS: GRID_CONFIG_STATIC.TIME_SLOTS,
                COURT_COUNT: GRID_CONFIG_STATIC.COURT_COUNT,
                TOTAL_WIDTH: width,
                TOTAL_HEIGHT: height,
                SLOT_WIDTH: (width - GRID_CONFIG_STATIC.COURT_LABEL_WIDTH) / GRID_CONFIG_STATIC.TIME_SLOTS,
                ROW_HEIGHT: (height - GRID_CONFIG_STATIC.HEADER_HEIGHT) / GRID_CONFIG_STATIC.COURT_COUNT
              };
              
              setEffectiveGridConfig(newConfig);
            }
          };

          // Initial calculation with small delay to ensure container is rendered
          const timer = setTimeout(() => {
            updateDimensions();
          }, 100);
          
          window.addEventListener('resize', updateDimensions);
          
          return () => {
            clearTimeout(timer);
            window.removeEventListener('resize', updateDimensions);
          };
        }, []);

        // Redraw canvas when data, time, or dimensions change
        useEffect(() => {
          const canvas = canvasRef.current;
          if (!canvas) return;
          
          const ctx = canvas.getContext('2d');
          const dpr = window.devicePixelRatio || 1;
          
          // Set canvas size for high DPI displays
          canvas.width = effectiveGridConfig.TOTAL_WIDTH * dpr;
          canvas.height = effectiveGridConfig.TOTAL_HEIGHT * dpr;
          canvas.style.width = `${effectiveGridConfig.TOTAL_WIDTH}px`;
          canvas.style.height = `${effectiveGridConfig.TOTAL_HEIGHT}px`;
          ctx.scale(dpr, dpr);
          
          // Draw everything with effectiveGridConfig
          CanvasDrawing.drawGrid(ctx, effectiveGridConfig);
          CanvasDrawing.drawTimeHeaders(ctx, effectiveGridConfig);
          CanvasDrawing.drawCourtLabels(ctx, courtData.courts, currentTime, effectiveGridConfig, getCourtBlockStatus);

          // Draw booking blocks
          courtData.courts.forEach((court, index) => {
            // Always call drawBookingBlock, it will handle new blocks internally
            CanvasDrawing.drawBookingBlock(ctx, court, index, currentTime, effectiveGridConfig, courtData);
          });
          
          // Draw now line
          CanvasDrawing.drawNowLine(ctx, currentTime, effectiveGridConfig);
          
        }, [courtData, currentTime, effectiveGridConfig]);

        // Format date display
        const formatDate = () => {
          const options = { weekday: 'long', month: 'long', day: 'numeric' };
          return currentTime.toLocaleDateString('en-US', options);
        };

        // Format player names for display
        const formatPlayerNames = (players) => {
          if (!players || players.length === 0) return '';
          
          const lastNames = players.map(p => {
            const parts = p.name.split(' ');
            return parts[parts.length - 1];
          });
          
          if (lastNames.length <= 2) {
            return lastNames.join(' & ');
          }
          return `${lastNames[0]} +${lastNames.length - 1}`;
        };

        const getNextAvailableCourts = () => {
          console.log('DEBUG: courtData exists?', !!courtData);
          console.log('DEBUG: calculatedAvailability exists?', !!(courtData?.calculatedAvailability));
          console.log('DEBUG: nextAvailable exists?', !!(courtData?.calculatedAvailability?.nextAvailable));
          console.log('DEBUG: nextAvailable length:', courtData?.calculatedAvailability?.nextAvailable?.length);
          
          // Use pre-calculated data if available
          if (courtData.calculatedAvailability && courtData.calculatedAvailability.nextAvailable) {
            console.log('DEBUG: Using pre-calculated data!');
            return courtData.calculatedAvailability.nextAvailable.map(court => ({
              courtNumber: court.courtNumber,
              availableAt: new Date(court.availableAt)
            }));
          }
          
          console.warn('Using fallback next available calculation - pre-calculated data not available');
          
          // Fallback logic...
          const availableCourts = [];
          
          if (!courtData || !courtData.courts) return availableCourts;
          
          courtData.courts.forEach((court, index) => {
            const courtNumber = index + 1;
            if (!court || (court.current === null)) {
              availableCourts.push({
                courtNumber: courtNumber,
                availableAt: new Date()
              });
            }
          });
          
          return availableCourts;
        };

        return (
          <div className="h-screen bg-gray-100 p-2 lg:p-3">
            {/* 16:9 Aspect Ratio Container */}
            <div className="w-full h-full mx-auto relative" style={{ aspectRatio: '16/9', maxWidth: 'calc(100vw - 32px)', maxHeight: 'calc(100vh - 32px)' }}>
            {/* Main White Card */}
              <div className="bg-white rounded-lg shadow-lg h-full flex flex-col">
                {/* Header with responsive text sizing */}
                <div className="text-center border-b flex-shrink-0 relative" style={{ padding: '1vh 0' }}>
                  {/* Orange flag for waiting list */}
                  {courtData && courtData.waitingGroups && Array.isArray(courtData.waitingGroups) && courtData.waitingGroups.length > 0 && (
                    <div className="absolute left-0 top-0 w-full h-full flex items-center" style={{ width: '17.6vw', minWidth: '224px', maxWidth: '400px' }}>
                      <div className="w-full flex justify-center">
                        <svg className="main-time" style={{ width: '1em', height: '1em' }} viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                          <path d="M5 22V2" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round"></path>
                          <path d="M5 4C5 4 8 3.5 11 4.5C14 5.5 17 6 17 6L17 8C17 8 14 8.5 11 9.5C8 10.5 5 10 5 10V4Z" fill="#FB923C" stroke="#EA580C" strokeWidth="1"></path>
                        </svg>
                      </div>
                    </div>
                  )}
                  
                 <div className="flex items-center justify-center gap-2">
                    <span className="main-time font-semibold" style={{ fontVariantNumeric: 'tabular-nums' }}>
                      {currentTime.toLocaleTimeString('en-US', { 
                        hour: 'numeric', 
                        minute: '2-digit', 
                        hour12: true 
                      }).replace(' AM', 'am').replace(' PM', 'pm')}
                    </span>
                    <span className="text-gray-400">â€¢</span>
                    <span className="main-date text-gray-600">{formatDate()}</span>
                  </div>
                </div>

                {/* Content Area - Waiting List + Canvas */}
                <div className="flex gap-2 lg:gap-3 p-2 lg:p-3 bg-gray-100 flex-grow overflow-hidden">
                  {/* Left Column - Waiting List and Next Available with viewport-based sizing */}
                  {courtData && courtData.waitingGroups && Array.isArray(courtData.waitingGroups) && courtData.waitingGroups.length > 0 && (
                    <div className="side-panel flex-shrink-0 h-full flex flex-col gap-2 lg:gap-3">
                      {/* Waiting List Section */}
                      <div className="bg-white rounded-lg shadow-sm flex-1 flex flex-col min-h-0">
                        <div className="text-white flex-shrink-0 rounded-t-lg section-header" style={{backgroundColor: '#15803d'}}>   
                          <div className="flex justify-between items-center">
                            <span className="font-semibold">Waiting</span>
                            <span style={{ fontSize: '1em' }}>Estimated</span>
                          </div>
                        </div>
                        <div className="section-content space-y-2 overflow-y-auto flex-grow scrollbar-hide">
                          {courtData.waitingGroups.map((group, index) => {
                            const waitTime = calculateEstimatedWaitTime(
                              index + 1,
                              courtData.courts,
                              currentTime,
                              TENNIS_CONFIG.TIMING.AVG_GAME_TIME_MIN,
                              courtData
                            );
                            
                            return (
                              <div key={index} className="bg-gray-50 rounded border border-gray-200" style={{ padding: '1vh' }}>
                                <div className="flex justify-between items-center">
                                  <div className="font-medium text-green-800" style={{ fontSize: '0.8em' }}>
                                    {formatPlayerNames(group.players)}
                                  </div>
                                  <div style={{ fontSize: '0.8em' }} className="text-gray-600">
                                    {waitTime === 0 ? (
                                      <span className="font-bold animate-pulse" style={{ color: '#FB923C' }}>You're Up!</span>
                                    ) : (
                                      `${waitTime} min`
                                    )}
                                  </div>
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      </div>

                      {/* Next Available Section */}
                      <div className="bg-white rounded-lg shadow-sm flex-1 flex flex-col min-h-0">
                        <div className="text-white flex-shrink-0 rounded-t-lg section-header" style={{backgroundColor: '#15803d'}}>
                          <span className="font-semibold">Next Available</span>
                        </div>
                        <div className="section-content space-y-2 overflow-y-auto flex-grow scrollbar-hide">
                          {getNextAvailableCourts().length === 0 ? (
                            <div className="text-gray-500 text-center" style={{ padding: '1vh 0' }}>
                              No courts currently occupied
                            </div>
                          ) : (
                            getNextAvailableCourts().slice(0, 6).map((court, index) => {
                              const timeStr = court.availableAt.toLocaleTimeString('en-US', {
                                hour: 'numeric',
                                minute: '2-digit',
                                hour12: true
                              }).replace(' AM', 'am').replace(' PM', 'pm');
                              
                              return (
                                <div key={index} className="bg-gray-50 rounded border border-gray-200" style={{ padding: '1vh' }}>
                                  <div className="flex justify-between items-center">
                                    <span className="font-medium text-green-800">
                                      Court {court.courtNumber}
                                    </span>
                                    <span className="text-gray-600">
                                      {timeStr}
                                    </span>
                                  </div>
                                </div>
                              );
                            })
                          )}
                        </div>
                      </div>
                    </div>
                  )}

                  {/* Canvas/Legend Container */}
                  <div ref={containerRef} className="bg-white rounded-lg shadow-sm border border-gray-300 flex flex-col flex-grow min-w-0">
                    <canvas 
                      ref={canvasRef}
                      className="block"
                    />
                    
                    {/* Legend with responsive text */}
                    <div className="bg-gray-50 border-t flex items-center justify-center gap-4 flex-shrink-0" style={{ padding: '1vh 1vw' }}>
                      <div className="flex items-center gap-1.5">
                        <div className="border border-gray-300 rounded" style={{ width: '0.8vw', height: '0.8vw', backgroundColor: 'white' }}></div>
                        <span className="legend-text">Available</span>
                      </div>
                      <div className="flex items-center gap-1.5">
                        <div className="rounded" style={{ width: '0.8vw', height: '0.8vw', backgroundColor: '#0ea5e9' }}></div>
                        <span className="legend-text">In Play</span>
                      </div>
                      <div className="flex items-center gap-1.5">
                        <div className="rounded" style={{ width: '0.8vw', height: '0.8vw', backgroundColor: '#d4a574' }}></div>
                        <span className="legend-text">Maintenance</span>
                      </div>
                      <div className="flex items-center gap-1.5">
                        <div className="rounded" style={{ width: '0.8vw', height: '0.8vw', backgroundColor: '#ccfbf1' }}></div>
                        <span className="legend-text">Lessons/Clinics</span>
                      </div>
                      <div className="flex items-center gap-1.5">
                        <div className="rounded" style={{ width: '0.8vw', height: '0.8vw', backgroundColor: '#94a3b8' }}></div>
                        <span className="legend-text">Wet</span>
                      </div>
                      <div className="flex items-center gap-1.5">
                        <div className="rounded" style={{ width: '0.8vw', height: '0.8vw', backgroundColor: '#9333ea' }}></div>
                        <span className="legend-text">League Play</span>
                      </div>
                      <div className="flex items-center gap-1.5">
                        <div className="rounded" style={{ width: '0.8vw', height: '0.8vw', backgroundColor: '#eab308' }}></div>
                        <span className="legend-text">Reserved</span>
                      </div>
                      <div className="flex items-center gap-1.5">
                        <div className="rounded border" style={{ width: '0.8vw', height: '0.8vw', backgroundColor: '#e8f5e9', borderColor: '#c5e1a5' }}></div>
                        <span className="legend-text">Overtime</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        );
      };

      // Render the application
      console.log('ðŸŽ¯ Rendering DataStore integrated timeline application...');
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<TennisCourtTimelineCanvas />);
      
      // Hide performance overlay after 30 seconds for production use
      setTimeout(() => {
        const overlay = document.getElementById('performance-overlay');
        if (overlay) {
          overlay.classList.add('hidden');
        }
      }, 30000);
      
      console.log('âœ… DataStore integrated Tennis Timeline Display loaded successfully!');
    }
  </script>
</body>
</html>